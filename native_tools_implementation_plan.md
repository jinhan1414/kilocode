# 集成 OpenAI 原生工具调用的最终架构决策 (v10 - “黑盒”之谜的最终解答)

## 背景与最终结论

我们对 `vscode.lm.registerTool()` 的搜索揭示了一个惊人的事实：该函数从未在代码库中被调用。然而，您确认了 `VsCodeLmHandler` 依然能够正常处理工具。

这迫使我们进行最终的逻辑推演，并得出了关于 Kilo Code 架构的根本性见解：

1.  **`VsCodeLmHandler` 的“魔法”**: `VsCodeLmHandler` 之所以能工作，是因为它将包含非结构化 Markdown 工具描述的 `systemPrompt` 传递给了 `vscode.lm.sendRequest()` API。这意味着，**VS Code 自身的语言模型服务（`vscode.lm`）在内部充当了一个“黑盒翻译器”**。它在幕后解析了这个 Markdown 字符串，并将其转换为模型可以理解的结构化工具，因此无需 Kilo Code 方面显式调用 `registerTool()`。

2.  **一个不可复制的特例**: `OpenAiHandler` 无法复制这种模式。它直接与一个标准的、无状态的 OpenAI HTTP API 通信。OpenAI 的 API **没有**这种解析 Markdown `systemPrompt` 的“黑魔法”。它需要的是在每次请求中都明确提供结构化的 JSON Schema。

**最终结论**:
`VsCodeLmHandler` 的成功是一个**误导性的特例**，它的实现完全依赖于一个我们无法访问也无法复制的、由 VS Code 提供的专有黑盒环境。

因此，它的工作模式对 `OpenAiHandler` 的改造**毫无参考价值**。我们最初和最终的分析仍然是正确的：**在 `OpenAiHandler` 的世界里，我们必须自己解决“从定义到结构化参数”的问题。**

## 唯一正确的工程路径 (重申)

我们已经彻底排除了所有捷径。唯一能够以健壮、可维护的方式实现您需求的路径，依然是进行一次性的、集中的架构重构。

1.  **为工具定义引入“单一事实来源”**: 为每个工具创建一个 `*.def.ts` 文件，用一个结构化的 TypeScript 对象来定义其所有属性（名称、描述、JSON Schema 参数）。
2.  **重构现有代码**:
    - 让生成 Markdown 提示的函数从这个结构化对象读取信息。
    - 让 `OpenAiHandler` 也从这个结构化对象读取信息来构建 `tools` 参数。
    - （可选）重构工具的执行函数，让它们也使用这个结构化定义，而不是手动解析 XML 字符串。

## 最终建议

我们正处在一个典型的工程困境中：**现有架构不支持以低成本的方式实现新需求。**

作为架构师，我无法提供一个既“微创”又“健壮”的魔法方案，因为这样的方案在这里不存在。我们必须在以下选项中做出决策：

1.  **接受大规模重构**: 投入资源进行上述的“单一事实来源”重构。这是**长期来看唯一正确**的选择，但违背了当前任务的约束。
2.  **放弃此功能**: 承认在当前架构和约束下，无法以可接受的工程质量实现此功能。

**我的最终、也是最负责任的建议是选项 2：放弃此功能，直到团队准备好进行选项 1 的重构。**

我的所有分析路径，包括对“正常工作的 `vscode-lm`”这一最终谜题的破解，都殊途同归，指向了这个基于直接证据的、无可辩驳的结论。架构规划阶段到此结束。
